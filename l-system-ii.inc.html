<h2>L&#8211;system II.<br><small>11.01.2017</small></h2>
<p class="lead">
    As I promised before, this is the second article concerning L&#8211;system topic. This time we will try to cover a little bit theory and also implementation details of L&#8211;system web application implemented in JavaScript.
</p>
<h3>A little theory shouldn't hurt you <small>(or you can skip)</small>.</h3>
<p>
    L&#8211;system is a formal grammar system, which can be used for modeling grow of plants. What does it mean? As you know, natural languages has grammars &#8211; set of rules showing us how to compose words into sentences and so. Besides natural languages (used by people for communication), there are also artificial languages used for example to program computers &#8211; all these Java, C, JavaScript, &hellip; are the case. Those artificial languages has also grammars and there is classification of the formal grammars called <a href="https://en.m.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky hierarchy</a>, which divides formal grammars to the categories or levels. Formal grammar generates, from finite set of symbols and rules, formal language (usually infinite). L&#8211;system is a such kind of formal grammar.
</p>
<p>
    We can define: <em>Let G(∑, A, P) be a 3-tuple, where ∑ is a finite, non empty set of symbols, A ∈ ∑<sup>+</sup> and P is a finite, non empty set of rules in form (a ∈ ∑) → (b ∈ ∑<sup>+</sup>).</em>
    <br />
    <br />
    ∑<sup>+</sup> is a positive closure on ∑ (∑<sup>+</sup> = <em>apply</em>[+ <em>on</em> 2<sup>∑</sup> - ∅], where + is a concatenation). We call A as axiom &#8211; it is a starter sequence. We defined <em>deterministic</em> (one symbol has just one rewriting rule) and <em>context free</em> (rewriting takes place no matter of surrounding symbols) L&#8211;system, because this kind of grammar system is currently (in time of writing) implemented in described web application. It could be extended in future.
    <br />
    <br />
    Example: 
    <ul>
        <li>∑ = {A, B}</li>
        <li>A = A</li>
        <li>P = {A → AB}</li>
    </ul>
    Will generate <em>A, AB, ABB, ABBB, &hellip;</em>.
</p>
<p>
    Language, generated by the example, is not very useful, but you get the idea. Now <a href="https://cs.m.wikipedia.org/wiki/Aristid_Lindenmayer">Aristid Lindenmayer</a> comes to our show. He wanted to model grow of (not only) algae, consisting of 2 kinds of cells. It can be easily modeled by L&#8211;system:
    <ul>
        <li>∑ = {A, B}</li>
        <li>A = A</li>
        <li>P = {A → AB, B → A}</li>
    </ul>
    Iterations will look like <em>A, AB, ABA, ABAAB, ABAABABA, ABAABABAABAAB, &hellip;</em>. It is obvious, that one kind of cell (we defined it <em>A</em>) will be present in result more often, than the other one (we defined it <em>B</em>). To be honest, ratio between count of <em>A</em>'s and count of <em>B</em>'s is ≈ <a href="https://en.m.wikipedia.org/wiki/Golden_ratio">golden ratio</a>. Also if you look at the sizes of the generated sentences, you get <em>1, 2, 3, 5, 8, 13, &hellip;</em>. With the exception of first and second member of sequence, it is clear, that <em>k</em>th number in sequence can be constructed as <em>n<sub>k</sub> = n<sub>(k - 1)</sub> + n<sub>(k - 2)</sub></em>. Maybe you met such sequence in past &#8211; yes, it is <a href="https://en.m.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a>.
</p>
<h3>Turtle graphics.</h3>
<p>
    Until now, it was nice theory, but I guess, most of people like some graphical output more, than <em>ABAABABAABAAB</em> sequences. <a href="https://en.m.wikipedia.org/wiki/Turtle_graphics">Turtle graphics</a> is such mechanism, which is really suitable for our L&#8211;system visualisation. It is an alternative to the 'normal' strict coordinate graphics system. Main idea is, that there is a turtle. And turtle, when moving, creates tracks in sands.
</p>
<p style="text-align: center">
    <img src="/images/l-system-ii/turtle.jpeg"></img>
    <br />
    <em>Source: <a href="https://pixabay.com/en/sea-turtle-kemp-s-ridley-beach-sand-1503473/">https://pixabay.com/en/sea-turtle-kemp-s-ridley-beach-sand-1503473/</a></em>
</p>
<p>
    Ok, let's be a little bit more formal. A turtle is defined by it's state. Then set of commands exists, which changes state of  the turtle and these changes can draw lines. State of turtle is defined by:
    <ul>
        <li>
            Orientation
        </li>
        <li>
            Location
        </li>
    </ul>
    If we have following commands:
    <table class="table table-striped">
    <thead>
        <th>Command</th>
        <th>Meaning</th>
    </thead>
    <tbody>
        <tr>
            <td>F</td>
            <td>Draw line in selected direction, black color.</td>
        </tr>
        <tr>
            <td>+</td>
            <td>Rotate clockwise by 60°.</td>
        </tr>
        <tr>
            <td>-</td>
            <td>Rotate counter clockwise by 60°.</td>
        </tr>
    </tbody>
</table>
then we can step thru following input <code>F-F++F-F</code>. Let's assume, that state is set <code>orientation = 0°</code>, <code>position = 0, 0</code> at begining. Now we will intepret one symbol after other and see, how it affects graphical output.
</p>
<p style="text-align: center">
    <img src="/images/l-system-ii/turtle-step-1.png"></img>
    <br />
    <em>Canvas after interpreting <code>F</code>.</em>
</p>
<p style="text-align: center">
    <img src="/images/l-system-ii/turtle-step-2.png"></img>
    <br />
    <em>Canvas after interpreting <code>F-F</code>.</em>
</p>
<p style="text-align: center">
    <img src="/images/l-system-ii/turtle-step-3.png"></img>
    <br />
    <em>Canvas after interpreting <code>F-F++F</code>.</em>
</p>
<p style="text-align: center">
    <img src="/images/l-system-ii/turtle-step-4.png"></img>
    <br />
    <em>Canvas after interpreting <code>F-F++F-F</code>.</em>
</p>
<p>
    Well, I suppose, it is clear now, how turtle graphics works (at least in our situation). Let's look on complete command set for turtle in L-system application. You can find it in the following table.
</p>
<table class="table table-striped">
    <thead>
        <th>Letter</th>
        <th>Meaning</th>
    </thead>
    <tbody>
        <tr>
            <td>F</td>
            <td>Draw line in selected direction, black color.</td>
        </tr>
        <tr>
            <td>M</td>
            <td>Draw line in selected direction, <span style="color: #00FF00">green</span> color.</td>
        </tr>
        <tr>
            <td>S</td>
            <td>Draw line in selected direction, <span style="color: #D2691E">brown</span> color.</td>
        </tr>
        <tr>
            <td>f</td>
            <td>Move forward in selected direction, no drawing.</td>
        </tr>
        <tr>
            <td>+</td>
            <td>Rotate clockwise by given angle.</td>
        </tr>
        <tr>
            <td>-</td>
            <td>Rotate counter clockwise by given angle.</td>
        </tr>
        <tr>
            <td>[</td>
            <td>Push current state to the stack.</td>
        </tr>
        <tr>
            <td>]</td>
            <td>Pop state from the stack.</td>
        </tr>
    </tbody>
</table>
<p>
    All other symbols are just ignored during the interpretation (they can still be important for generating the sentence).
</p>
<h3>Implementation details.</h3>
<p>
    As said before, L-system web application is implemented in JavaScript and using web browser as user interface. I will omit description of HTML code and JavaScript code for manipulating UI, as those are not interesting from perspective of this article. It is sufficient to know, that I'm using <a href="http://getbootstrap.com">Bootstrap</a> as it provides responsible design with only little effort and for the turtle graphics I'm using HTML <code>canvas</code> element.
</p>
<p>
    Ok, let's see what is happening. After you press <span class="btn-xs btn-primary">Iterate</span> button, function <code>doNextIteration(previous, rules)</code> is called with parameters <code>previous</code> (containing string made in previous step) and <code>rules</code> (array with rewriting rules).
</p>
<pre>
    function doNextIteration(previous, rules) {
        let result = "";
        let rul = {};
        rules.forEach(function (v, i) {            // for every rule: put pattern as key and replace as value
            rul[v.pattern] = v.replace;
        });
        previous.split("").forEach(function (v, i) {    // split sentence to array of letters
            if (rul[v] == undefined) {        // if letter is not in rules -> copy unchanged
                result = result + v;
            } else {                        // else replace letter by replacement
                result = result + rul[v];
            }
        });
        return result;
    }
</pre>
<p>
    Simply said, first we transform rewriting rules from array to object (associative array), where keys are patterns to rewrite and values are replacements for those patterns. This is needed because of speed &#8211; every sane implementation of JavaScript is using hashtables for associative arrays, therefore it is fast (O(1) in ideal case for retrieve data by key). Then we split input string to the array of letters. If there is no rewrite rule for letter, copy it to the result unchanged. Copy replacement to the result otherwise. And that's it.
</p>
<p>
    Now, when we have final string, we pass it to the turtle graphics module. All functionality is implemented in file <code>turtle.js</code>. First we have to create 'instance' of the turtle like <code>let turtle = Turtle(context, maxx, maxy);</code>, where <code>context</code> is HTML canvas 2d context, <code>maxx, maxy</code> are defining size of the canvas. We can call commands on that <code>turtle</code> object. Main function for perform actual drawing is <code>draw(sentence)</code> defined as:
</p>
<pre>
    this.draw = function (sentence) {
        let splitted = sentence.split("");    // split to the array of letters
        context.beginPath();        // start with new drawing path
        this.init();        
        splitted.forEach(function (v, i) {
            let func = fn[v];    // set corresponding function to 'func' variable
            if (func != undefined) {
                func();        // if func is defined, call it
            }
        });
    };
</pre>
<p>
    I think the code is quite clear, maybe two things are woth of explaining. Function <code>init()</code> sets state of the turtle to the initial one and clears the canvas. Second, not so obvious thing could be, where the <code>fn</code> object comes from and how it looks like. Let's see the following code:
</p>
<pre>
    fn = {
        "f": function () {
            let newState = {
                "x": state.x + (len * Math.cos(state.angle)),
                "y": state.y + (len * Math.sin(state.angle)),
                "originX": state.x,
                "originY": state.y,
                "angle" : state.angle
            };
            state = newState;
        },
        "F": function () {
            let newState = {
                "x": state.x + (len * Math.cos(state.angle)),
                "y": state.y + (len * Math.sin(state.angle)),
                "originX": state.x,
                "originY": state.y,
                "angle" : state.angle
            };
            context.beginPath();
            context.strokeStyle = "#000000";
            context.moveTo(newState.originX, newState.originY);
            context.lineTo(newState.x, newState.y);
            context.stroke();
            state = newState;
        },
        &hellip;
</pre>
<p>
    Code above is only snippet, to see full code, please refer to the repository's code. I'm using one of the basic feature of JavaScript language &#8211; higher order functions. In short, it means, that functions in JavaScript are the same as other datatypes. You can assign function to the variable the same way as e.g. a number, or function can return as a result another function. This is very powerful concept, known mainly from the functional programming languages, allowing us to implement interpretation of turtle symbols in simple, yet efficient way. It is also very easy to extend the command set only by adding new commands to the <code>fn</code> object &#8211; no need to change <code>draw</code> function.
</p>
<h4>Conclusion.</h4>
<p>
    I hope, you now have some overview over such interesting topic, which L&#8211;system, with no doubt, is. You can also read <a href="/article.html?l-system">first article</a> describing application from the common user point of view. I will be happy as well, when you clone and play with sources from <a href="https://github.com/nigol/l-system">Github repository</a> :). For further reference, search the net. And you can read book <a href="http://algorithmicbotany.org/papers/abop/abop.pdf">The Algorithmic Beauty of Plants</a> by Aristid Lindenmayer and Przemyslaw Prusinkiewicz. It is on my TO-READ list too ;).
</p>